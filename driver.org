#+STARTUP: indent
* 驱动
** 串口
*** 基本系统
#+begin_src c :tangle /dev/shm/boxos/uart.h
  #ifndef __UART_H
  #define __UART_H
  #include <stdint.h>
  #include "ring.h"
  struct uart_context_t;
  typedef void (* uart_start_fn)(void);
  typedef void (* uart_setup_fn)(struct uart_context_t * ctx);
  typedef void (* uart_eventloop_fn)(struct uart_context_t * ctx);
  struct uart_context_t {
    uint16_t baudrate;
    uint8_t databits, stopbits;
    struct ring_t * tx, * rx;
    uint32_t loop_timer;
    uint32_t loop_interval;
    uint32_t tx_timer;
    uint32_t tx_interval;
    uint32_t tx_to_send;
    //uint8_t uart;
    uart_setup_fn setup;
    uart_start_fn start;
    uart_eventloop_fn eventloop;
  };


  void uart_init(uint8_t idx, struct uart_context_t * ctx);
  void uart_setup(void);
  void uart_start(void);
  void uart_eventloop(void);
  struct uart_context_t * uart_context(uint8_t idx);
  #endif
#+end_src
#+begin_src c :tangle /dev/shm/boxos/uart.c
  #include <stddef.h>
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/usart.h>
  #include <libopencm3/cm3/nvic.h>
  #include "defination.h"
  #include "uart.h"
  #include "console.h"

  static int RCC_UART[5] = {
    RCC_USART1,
    RCC_USART2,
    RCC_USART3,
    RCC_UART4,
    RCC_UART5,
  };

  static int RCC_UART_GPIO[5] = {
    0,
    RCC_GPIOA,
    RCC_GPIOB,
    RCC_GPIOC,
    RCC_GPIOC | RCC_GPIOD,
  };

  static uint8_t NVIC_UART_IRQ[5] = {
    NVIC_USART1_IRQ,
    NVIC_USART2_IRQ,
    NVIC_USART3_IRQ,
    NVIC_UART4_IRQ,
    NVIC_UART5_IRQ,
  };

  static uint32_t TX_GPIO_PORT[5] = {
    0,
    GPIOA,
    GPIOB,
    GPIOC,
    GPIOC,
  };

  static uint32_t RX_GPIO_PORT[5] = {
    0,
    GPIOA,
    GPIOB,
    GPIOC,
    GPIOD,
  };

  static int TX_GPIO_IO[5] = {
    0,
    GPIO_USART2_TX,
    GPIO_USART3_TX,
    GPIO_UART4_TX,
    GPIO_UART5_TX,
  };

  static int RX_GPIO_IO[5] = {
    0,
    GPIO_USART2_RX,
    GPIO_USART3_RX,
    GPIO_UART4_RX,
    GPIO_UART5_RX,
  };

  static uint32_t UART[5] = {
    USART1,
    USART2,
    USART3,
    UART4,
    UART5,
  };

  struct uart_context_t * ctxs[5] = { NULL, NULL, NULL, NULL, NULL };

  void uart_init(uint8_t idx, struct uart_context_t * ctx) {
    ctxs[idx - 1] = ctx;
  }

  void uart_setup() {
    for (uint8_t i = 0; i < 5; i ++) {
      if (ctxs[i] != NULL) {
        ctxs[i]->setup(ctxs[i]);

        rcc_periph_clock_enable(RCC_UART[i]);
        rcc_periph_clock_enable(RCC_UART_GPIO[i]);

        nvic_enable_irq(NVIC_UART_IRQ[i]);

        gpio_set_mode(TX_GPIO_PORT[i], GPIO_MODE_OUTPUT_50_MHZ, GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, TX_GPIO_IO[i]);
        gpio_set_mode(RX_GPIO_PORT[i], GPIO_MODE_INPUT, GPIO_CNF_INPUT_FLOAT, RX_GPIO_IO[i]);

        /* Setup UART parameters. */
        usart_set_baudrate(UART[i], ctxs[i]->baudrate);
        usart_set_databits(UART[i], ctxs[i]->databits);
        usart_set_stopbits(UART[i], ctxs[i]->stopbits);
        usart_set_mode(UART[i], USART_MODE_TX_RX);
        usart_set_parity(UART[i], USART_PARITY_NONE);
        usart_set_flow_control(UART[i], USART_FLOWCONTROL_NONE);

        /* Enable LOCK Receive interrupt. */
        USART_CR1(UART[i]) |= USART_CR1_RXNEIE;

        /* Finally enable the USART. */
        usart_enable(UART[i]);

      }
    }
  }

  void uart_start() {

    for (uint8_t i = 0; i < 5; i ++) {
      if (ctxs[i] != NULL) {
        if (ctxs[i]->start != NULL) {
          ctxs[i]->start();
        }
      }
    }
  }

  void uart_eventloop() {
    for (uint8_t i = 0; i < 5; i ++) {
      struct uart_context_t * ctx = ctxs[i];
      if (ctx != NULL) {
        if (systick > ctx->loop_timer) {
          ctx->loop_timer = systick + ctx->loop_interval;
        }
        if (systick > ctx->tx_timer) {
          ctx->tx_timer = systick + ctx->tx_interval;
          if (ctx->tx_to_send == 0) {
            if (ring_length(ctx->tx) > 1) {
              // saved length as varint type
              uint32_t len = 0;
              uint8_t byte = 0;
              uint8_t count = 0;
              ring_read(ctx->tx, &byte);
              while (byte > 127 && ring_length(ctx->tx) > 0) {
                ring_read(ctx->tx, &byte);
                len |= (byte & 0x7F) << (count * 7);
                count ++;
              }
              len |= (byte & 0x7F) << (count * 7);

              ctx->tx_to_send = len;
              USART_CR1(UART[i]) |= USART_CR1_TXEIE;
            }
          } else {
            USART_CR1(UART[i]) |= USART_CR1_TXEIE;
          }
        }
        ctx->eventloop(ctx);
      }
    }
  }

  struct uart_context_t * uart_context(uint8_t idx) {
    return ctxs[idx - 1];
  }

  static void uart_isr(uint8_t idx) {

    uint8_t data = 0;
    uint32_t result = 0;

    struct uart_context_t * ctx = ctxs[idx];
    if (ctx == NULL) return;

    /* Check if we were called because of RXNE. */
    if (((USART_CR1(UART[idx]) & USART_CR1_RXNEIE) != 0) && ((USART_SR(UART[idx]) & USART_SR_RXNE) != 0)) {

      /* Retrieve the data from the peripheral. */
      data = usart_recv(UART[idx]);
      ring_write(ctx->rx, data);
      /*
      if (idx == 3) {
        console_byte(data);
        console_char(' ');
      }
      */
      if (ring_available(ctx->rx) == 0) {
        /* Disable the RXNEIE interrupt */
        USART_CR1(UART[idx]) &= ~USART_CR1_RXNEIE;
      }
    }

    /* Check if we were called because of TXE. */
    if (((USART_CR1(UART[idx]) & USART_CR1_TXEIE) != 0) && ((USART_SR(UART[idx]) & USART_SR_TXE) != 0)) {
      if (ctx->tx_to_send == 0) {
        USART_CR1(UART[idx]) &= ~USART_CR1_TXEIE;
        return;
      }

      result = ring_read(ctx->tx, &data);

      if (result == 0) {
        /* Disable the TXE interrupt, it's no longer needed. */
        USART_CR1(UART[idx]) &= ~USART_CR1_TXEIE;
      } else {
        /* Put data into the transmit register. */
        usart_send(UART[idx], data);
        ctx->tx_to_send --;
      }
    }
  }

  void usart3_isr(void) {
    uart_isr(3 - 1);
  }

  void uart4_isr(void) {
    uart_isr(4 - 1);
  }
#+end_src
*** UART3
UART3 总线上以 TDMA 方式运行通讯协议，目标受众是刷卡器，扭蛋机这种主动
通讯的设备。UART3 把一秒钟分为 16 份，在第一段和第十六段上发送数据，剩
余时刻接收总线上的响应数据。

在没有任务要发给总线上的设备时，UART3 定时广播网络状态给总线上的设备。
**** 基本框架
#+begin_src c :tangle /dev/shm/boxos/uart3.h
  #ifndef __UART3_H
  #define __UART3_H

  struct uart_context_t;

  void uart3_setup(struct uart_context_t * ctx);
  void uart3_start(void);
  void uart3_eventloop(struct uart_context_t * ctx);

  #endif
#+end_src
#+begin_src c :tangle /dev/shm/boxos/uart3.c
  #include "uart3.h"
  #include "uart.h"
  #include "defination.h"
  #include "utility.h"
  #include "ring.h"
  #include "uart3-fsm.h"
  #include "uart3-packet.h"
  #include "console.h"
  #include "card-reader.h"
  #include "egg.h"
  #include "network.h"

  #define UART3_TX_BUFFER_SIZE 10
  #define UART3_RX_BUFFER_SIZE 8
  static struct ring_t tx, rx;
  static uint8_t tx_buffer[2 << (UART3_TX_BUFFER_SIZE - 1)], rx_buffer[2 << (UART3_RX_BUFFER_SIZE - 1)];

  struct uart3_context_t {
    uint8_t buf[512];
    uint16_t ptr;
    uint8_t byte;
    uint8_t len;
    uint32_t countdown;
    uint32_t rx_timer;
  };

  static uint32_t uart3_state = UART3_READY_STATE;
  static struct uart3_context_t context;
  static uint32_t ping_timer;

  static void uart3_callback(uint8_t * buf, uint32_t size);
  static void uart3_ping(void);

  <<uart3-setup>>

  void uart3_start() {
    ping_timer = 0;
  }

  <<uart3-mainloop>>
  <<uart3-fsm>>
  <<uart3-callback>>
  <<uart3-ping>>
#+end_src
**** 配置
#+begin_src c :noweb-ref uart3-setup
  void uart3_setup(struct uart_context_t * ctx) {

    ring_init(&tx, tx_buffer, UART3_TX_BUFFER_SIZE);
    ring_init(&rx, rx_buffer, UART3_RX_BUFFER_SIZE);

    ctx->tx = &tx;
    ctx->rx = &rx;
    ctx->baudrate = 9600;
    ctx->databits = 8;
    ctx->stopbits = 1;
    ctx->tx_interval = 999; // 1000 ms
    ctx->loop_interval = 999; // 1000 ms

    bzero(&context, sizeof(struct uart3_context_t));
    context.countdown = 0xFFFFFFFF;
    context.rx_timer = 0xFFFFFFFF;

    card_reader_setup(ctx->tx, ctx->rx);
    egg_setup(ctx->tx, ctx->rx);
  }
#+end_src
**** 主循环
#+begin_src c :noweb-ref uart3-mainloop
  void uart3_eventloop(struct uart_context_t * ctx) {
    if (systick > ping_timer) {
      ping_timer = systick + 499;
      if (ring_length(ctx->tx) == 0) {
        uart3_ping();
      }
    }
    card_reader_eventloop();
    egg_eventloop();
    struct uart3_context_t * pctx = &context;
    uint32_t rxlen = ring_length(ctx->rx);
    if (rxlen > 0) {
      pctx->rx_timer = systick;

      for (uint32_t i = 0; i < rxlen; i ++) {
        if (pctx->countdown <= 0xFFFF) {
          pctx->countdown --;
        }
        uint8_t byte;
        ring_read(ctx->rx, &byte);
        pctx->byte = byte;
        if (byte < 0x5A) {
          uart3_state = uart3_transform_state(uart3_state, UART3_0X00_0X59_EVENT, pctx);
        } else if (byte == 0x5A) {
          uart3_state = uart3_transform_state(uart3_state, UART3_0X5A_EVENT, pctx);
        } else if (0x5A < byte && byte < 0xA5) {
          uart3_state = uart3_transform_state(uart3_state, UART3_0X5B_0XA4_EVENT, pctx);
        } else if (byte == 0xA5) {
          uart3_state = uart3_transform_state(uart3_state, UART3_0XA5_EVENT, pctx);
        } else if (0xA5 < byte) {
          uart3_state = uart3_transform_state(uart3_state, UART3_0XA6_0XFF_EVENT, pctx);
        }
        if (pctx->countdown == 0) {
          uart3_state = uart3_transform_state(uart3_state, UART3_COUNTDOWN_EQUALS_0_EVENT, pctx);
        }
      }
    }

    if (pctx->rx_timer != 0xFFFFFFFF && (systick - pctx->rx_timer > 999)) { // 1s
      uart3_state = uart3_transform_state(uart3_state, UART3_EOI_EVENT, pctx);
      pctx->rx_timer = 0xFFFFFFFF;
    }
  }
#+end_src
**** 协议状态机
#+begin_src c :noweb-ref uart3-fsm
  void uart3_do_action(enum UART3_ACTION action, void * data) {
    struct uart3_context_t * pctx = (struct uart3_context_t *) data;
    switch (action) {
    case UART3_APPEND_ACTION:
      pctx->buf[pctx->ptr ++] = pctx->byte;
      break;
    case UART3_CLEAR_ACTION:
      bzero(pctx, sizeof(struct uart3_context_t));
      pctx->countdown = (uint32_t) 0xFFFFFFFFFF;
      break;
    case UART3_APPEND_COMMA_SET_COUNTDOWN_ACTION:
      pctx->buf[pctx->ptr ++] = pctx->byte;
      pctx->len = pctx->byte;
      pctx->countdown = pctx->len;
      break;
    case UART3_CALLBACK_ACTION:
      uart3_callback(pctx->buf, pctx->ptr);
      bzero(pctx, sizeof(struct uart3_context_t));
      pctx->countdown = (uint32_t) 0xFFFFFFFFFF;
      break;
    }
  }
#+end_src
**** 协议回调
#+begin_src c :noweb-ref uart3-callback
  static void uart3_callback(uint8_t * buf, uint32_t size) {
    uint32_t estimated = uart3_packet_estimate_decode_size(buf, size);
    uint8_t tmp[estimated];
    bzero(tmp, estimated);
    uart3_packet_t * packet = (uart3_packet_t *) tmp;
    switch(uart3_packet_decode(buf, size, estimated, packet)) {
    case CARD_READER:
      card_reader_callback(&packet->payload.card_reader);
      break;
    case EGG:
      egg_callback(packet->devid, &packet->payload.egg);
      break;
    default:
      break;
    }
  }
#+end_src
**** 广播网络状态
#+begin_src c :noweb-ref uart3-ping
  static void uart3_ping() {
    uart3_packet_t packet;
    bzero(&packet, sizeof(uart3_packet_t));
    packet.devtype = ALL;
    packet.devid = 0xFF;
    packet.payload.all.online = network_is_online();
    populate_uart3_packet_to_tx(&packet, &tx);
  }
#+end_src
**** 协议封包
#+begin_src c :tangle /dev/shm/boxos/uart3-packet.h
  #ifndef __UART3_PACKET_H
  #define __UART3_PACKET_H
  #include <stdint.h>
  #include "card_payload.h"
  #include "egg_payload.h"
  #include "uart3_payload.h"

  typedef enum UART3_DEVTYPE {
    CARD_READER = 0x10,
    EGG = 0x20,
    ALL = 0xF0,
  } uart3_devtype_t;

  typedef struct {
    uart3_devtype_t devtype;
    uint8_t devid;
    union {
      card_payload_t card_reader;
      egg_payload_t egg;
      uart3_payload_t all;
    } payload;
  } uart3_packet_t;

  uint32_t uart3_packet_calculate_encode_size(uart3_packet_t * packet);
  uint32_t uart3_packet_encode(uart3_packet_t * packet, uint8_t * buf, uint32_t size);
  uint32_t uart3_packet_estimate_decode_size(uint8_t * buf, uint8_t size);
  uart3_devtype_t uart3_packet_decode(uint8_t * buf, uint8_t size, uint8_t estimated, uart3_packet_t * packet);

  #define _populate_uart3_packet_to_tx_1(packet, tx, line) do {           \
      uint32_t elen##line = uart3_packet_calculate_encode_size(packet);   \
      uint8_t ebuf##line[elen##line];                                     \
      uint8_t size_of_len##line = 0;                                      \
      if (elen##line < 128) {                                             \
        size_of_len##line = 1;                                            \
      } else if (elen##line < 16384) {                                    \
        size_of_len##line = 2;                                            \
      } else if (elen##line < 2097152) {                                  \
        size_of_len##line = 3;                                            \
      } else {                                                            \
        size_of_len##line = 4;                                            \
      }                                                                   \
      if (ring_available(tx) >= elen##line + size_of_len##line) {         \
        bzero(ebuf##line, elen##line);                                    \
        uint32_t len##line = uart3_packet_encode(packet, ebuf##line, elen##line); \
        elen##line = len##line;                                           \
        while (elen##line > 0) {                                          \
          ring_write(tx, elen##line & 0x7F);                              \
          elen##line = elen##line >> 7;                                   \
        }                                                                 \
        ring_write_array(tx, ebuf##line, 0, len##line);                   \
      }                                                                   \
    } while (0)

  #define _populate_uart3_packet_to_tx_0(packet, tx, line) _populate_uart3_packet_to_tx_1(packet, tx, line)

  #define populate_uart3_packet_to_tx(packet, tx) _populate_uart3_packet_to_tx_0(packet, tx, __LINE__)
  #endif
#+end_src
#+begin_src c :tangle /dev/shm/boxos/uart3-packet.c
  #include "uart3-packet.h"
  #include "hash.h"

  /*
    packet layout:

            +-+-+-+-+-+-+-+-+
    byte 0  |1|0|1|0|0|1|0|1|   magic number 0
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 1  |0|1|0|1|1|0|1|0|   magic number 1
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 2  |x|x|x|x|x|x|x|x|   adle32-0 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 3  |x|x|x|x|x|x|x|x|   adle32-1 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 4  |x|x|x|x|x|x|x|x|   adle32-2 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 5  |x|x|x|x|x|x|x|x|   adle32-3 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 6  |x|x|x|x|x|x|x|x|   type (4 bit) and id (4 bit)
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 7  |x|x|x|x|x|x|x|x|   length of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 8  |x|x|x|x|x|x|x|x|   begin of data
            +-+-+-+-+-+-+-+-+
                    .
                    .
                    .
            +-+-+-+-+-+-+-+-+
    byte n  |x|x|x|x|x|x|x|x|   end of data
            +-+-+-+-+-+-+-+-+

  ,*/


  #define UART3_PACKET_META_SIZE (2 + 4 + 1 + 1) // magic number + checksum + type and id + length

  uint32_t uart3_packet_calculate_encode_size(uart3_packet_t * packet) {
    switch (packet->devtype) {
    case CARD_READER:
      return card_payload_calculate_size(&packet->payload.card_reader) + UART3_PACKET_META_SIZE;
    case EGG:
      return egg_payload_calculate_size(&packet->payload.egg) + UART3_PACKET_META_SIZE;
    case ALL:
      return uart3_payload_calculate_size(&packet->payload.all) + UART3_PACKET_META_SIZE;
    default:
      return 0;
    }
  }


  uint32_t uart3_packet_encode(uart3_packet_t * packet, uint8_t * buf, uint32_t size) {

    buf[0] = 0xA5;
    buf[1] = 0x5A;
    buf[6] = (packet->devtype | packet->devid) | 0x80 /* from epigyny to hypogyny*/;

    switch (packet->devtype) {
    case CARD_READER:
      buf[7] = card_payload_encode_zeropack(&packet->payload.card_reader, buf + UART3_PACKET_META_SIZE, size - UART3_PACKET_META_SIZE);
      break;
    case EGG:
      buf[7] = egg_payload_encode_zeropack(&packet->payload.egg, buf + UART3_PACKET_META_SIZE, size - UART3_PACKET_META_SIZE);
      break;
    case ALL:
      buf[7] = uart3_payload_encode_zeropack(&packet->payload.all, buf + UART3_PACKET_META_SIZE, size - UART3_PACKET_META_SIZE);
      break;
    default:
      buf[7] = 0;
      break;
    }

    uint32_t checksum = adler32(buf + 2 + 4, buf[7] + 2); // include type and id, length
    buf[2] = checksum & 0xFF;
    buf[3] = (checksum >> 8) & 0xFF;
    buf[4] = (checksum >> 16) & 0xFF;
    buf[5] = (checksum >> 24) & 0xFF;

    return buf[7] + UART3_PACKET_META_SIZE;
  }

  uint32_t uart3_packet_estimate_decode_size(uint8_t * buf, uint8_t size) {
    if (size <= UART3_PACKET_META_SIZE) return 0;
    if (buf[0] != 0xA5 || buf[1] != 0x5A) {
      return 0;
    }
    uint32_t len = buf[7];
    if (len + UART3_PACKET_META_SIZE > size) return 0;
    uint32_t checksum = adler32(buf + 2 + 4, len + 2);
    if ((buf[2] == (checksum & 0xFF)) &&
        (buf[3] == ((checksum >> 8) & 0xFF)) &&
        (buf[4] == ((checksum >> 16) & 0xFF)) &&
        (buf[5] == ((checksum >> 24) & 0xFF))) {
      switch (buf[6] & 0xF0) {
      case CARD_READER:
        return card_payload_estimate_zeropack_size(buf + UART3_PACKET_META_SIZE, len) + UART3_PACKET_META_SIZE;
      case EGG:
        return egg_payload_estimate_zeropack_size(buf + UART3_PACKET_META_SIZE, len) + UART3_PACKET_META_SIZE;
      case ALL:
        return uart3_payload_estimate_zeropack_size(buf + UART3_PACKET_META_SIZE, len) + UART3_PACKET_META_SIZE;
      default:
        return 0;
      }
    }
    return 0;
  }

  uart3_devtype_t uart3_packet_decode(uint8_t * buf, uint8_t size, uint8_t estimated, uart3_packet_t * packet) {

    if (size <= UART3_PACKET_META_SIZE) return 0;
    if (buf[0] != 0xA5 || buf[1] != 0x5A) {
      return 0;
    }
    uint32_t len = buf[7];
    if (len + UART3_PACKET_META_SIZE > size) return 0;
    uint32_t checksum = adler32(buf + 2 + 4, len + 2);
    if ((buf[2] == (checksum & 0xFF)) &&
        (buf[3] == ((checksum >> 8) & 0xFF)) &&
        (buf[4] == ((checksum >> 16) & 0xFF)) &&
        (buf[5] == ((checksum >> 24) & 0xFF))) {
      packet->devtype = buf[6] & 0xF0;
      packet->devid = buf[6] & 0x0F;
      uint8_t tmp[estimated];
      switch (packet->devtype) {
      case CARD_READER:
        card_payload_decode_zeropack(buf + UART3_PACKET_META_SIZE, size - UART3_PACKET_META_SIZE, tmp, &packet->payload.card_reader);
        return CARD_READER;
      case EGG:
        egg_payload_decode_zeropack(buf + UART3_PACKET_META_SIZE, size - UART3_PACKET_META_SIZE, tmp, &packet->payload.egg);
        return EGG;
      case ALL:
        uart3_payload_decode_zeropack(buf + UART3_PACKET_META_SIZE, size - UART3_PACKET_META_SIZE, tmp, &packet->payload.all);
        return ALL;
      default:
        return 0;
      }
    }
    return 0;
  }
#+end_src
**** 通用协议数据结构
#+begin_src lisp :tangle /dev/shm/boxos/uart3.tr
  (struct uart3-payload
    (int 0 sn) ;; 请求序列号
    (byte 1 online) ;; 命令编号
    )
#+end_src

*** UART4
UART4 总线上运行的是锁控，充电检测和 RFID。锁控系统采用自有封包格式，
充电检测和 RFID 采用统一的封包格式。
***** 基本框架
#+begin_src c :tangle /dev/shm/boxos/uart4.h
  #ifndef __UART4_H
  #define __UART4_H

  struct uart_context_t;

  void uart4_setup(struct uart_context_t * ctx);
  void uart4_start(void);
  void uart4_eventloop(struct uart_context_t * ctx);

  #endif
#+end_src
#+begin_src c :tangle /dev/shm/boxos/uart4.c
  #include "uart4.h"
  #include "uart.h"
  #include "defination.h"
  #include "utility.h"
  #include "ring.h"
  #include "uart4-fsm.h"
  #include "lock.h"
  #ifndef ENGINEER_MODE
  #include "charger.h"
  #include "rfid-reader.h"
  #endif
  #include "console.h"

  <<uart4-context>>

  #define UART4_TX_BUFFER_SIZE 10
  #define UART4_RX_BUFFER_SIZE 8
  static struct ring_t tx, rx;
  static uint8_t tx_buffer[2 << (UART4_TX_BUFFER_SIZE - 1)], rx_buffer[2 << (UART4_RX_BUFFER_SIZE - 1)];

  static uint32_t uart4_state = UART4_READY_STATE;
  static struct uart4_context_t context;

  <<uart4-setup>>

  void uart4_start() {
  #ifndef ENGINEER_MODE
    lock_start();
    charger_start();
  #endif
  }

  <<uart4-mainloop>>
  <<uart4-callback>>
  <<uart4-fsm>>
#+end_src
***** 配置
#+begin_src c :noweb-ref uart4-setup
  void uart4_setup(struct uart_context_t * ctx) {

    ring_init(&tx, tx_buffer, UART4_TX_BUFFER_SIZE);
    ring_init(&rx, rx_buffer, UART4_RX_BUFFER_SIZE);

    ctx->tx = &tx;
    ctx->rx = &rx;
    ctx->baudrate = 9600;
    ctx->databits = 8;
    ctx->stopbits = 1;
  #ifdef LOCK_FC
    ctx->tx_interval = 999; // 1000 ms
  #else
    ctx->tx_interval = 499; // 500 ms
  #endif
    ctx->loop_interval = 1; // 1 ms

    bzero(&context, sizeof(struct uart4_context_t));
    context.countdown = 0xFFFFFFFF;
    context.rx_timer = 0xFFFFFFFF;

    lock_setup(ctx->tx, ctx->rx);
  #ifndef ENGINEER_MODE
    charger_setup(ctx->tx, ctx->rx);
    rfid_reader_setup(ctx->tx, ctx->rx);
  #endif
  }
#+end_src
***** 主循环
#+begin_src c :noweb-ref uart4-mainloop
  void uart4_eventloop(struct uart_context_t * ctx) {
    lock_eventloop();
  #ifndef ENGINEER_MODE
    charger_eventloop();
    rfid_reader_eventloop();
  #endif
    struct uart4_context_t * pctx = &context;
    uint32_t rxlen = ring_length(ctx->rx);
    if (rxlen > 0) {
      pctx->rx_timer = systick;

      for (uint32_t i = 0; i < rxlen; i ++) {
        if (pctx->countdown <= 0xFFFF) {
          pctx->countdown --;
        }
        uint8_t byte;
        ring_read(ctx->rx, &byte);
        pctx->byte = byte;
        if (byte == 0x00) {
          uart4_state = uart4_transform_state(uart4_state, UART4_0X00_EVENT, pctx);
        } else if (byte == 0x01) {
          uart4_state = uart4_transform_state(uart4_state, UART4_0X01_EVENT, pctx);
        } else if (byte == 0x02) {
          uart4_state = uart4_transform_state(uart4_state, UART4_0X02_EVENT, pctx);
        } else if (0x03 <= byte && byte <= 0x08) {
          uart4_state = uart4_transform_state(uart4_state, UART4_0X03_MINUS_0X08_EVENT, pctx);
        } else if (0x09 <= byte && byte <= 0x14) {
          uart4_state = uart4_transform_state(uart4_state, UART4_0X09_MINUS_0X14_EVENT, pctx);
        } else if (byte == 0x33) {
          uart4_state = uart4_transform_state(uart4_state, UART4_0X33_EVENT, pctx);
        } else if (byte == 0x3C) {
          uart4_state = uart4_transform_state(uart4_state, UART4_0X3C_EVENT, pctx);
        } else if (byte == 0x55) {
          uart4_state = uart4_transform_state(uart4_state, UART4_0X55_EVENT, pctx);
        } else if (byte == 0xAA) {
          uart4_state = uart4_transform_state(uart4_state, UART4_0XAA_EVENT, pctx);
        } else if (byte == 0xC3) {
          uart4_state = uart4_transform_state(uart4_state, UART4_0XC3_EVENT, pctx);
        } else if (byte == 0xCC) {
          uart4_state = uart4_transform_state(uart4_state, UART4_0XCC_EVENT, pctx);
        } else {
          uart4_state = uart4_transform_state(uart4_state, UART4_OTHER_EVENT, pctx);
        }
        if (pctx->countdown == 0) {
          uart4_state = uart4_transform_state(uart4_state, UART4_COUNTDOWN_EQUALS_0_EVENT, pctx);
        }
      }
    }

    if (pctx->rx_timer != 0xFFFFFFFF && (systick - pctx->rx_timer > 999)) { // 1s
      uart4_state = uart4_transform_state(uart4_state, UART4_EOF_EVENT, pctx);
      pctx->rx_timer = 0xFFFFFFFF;
    }
  }
#+end_src
***** 协议状态机
****** 解析上下文
#+begin_src c :noweb-ref uart4-context
  struct uart4_context_t {
    uint8_t buf[512];
    uint16_t ptr;
    uint8_t byte;
    uint8_t len0;
    uint8_t len1;
    uint32_t countdown;
    uint32_t rx_timer;
  };
#+end_src
****** 执行动作
#+begin_src c :noweb-ref uart4-fsm
  void uart4_do_action(enum UART4_ACTION action, void * data) {
    struct uart4_context_t * pctx = (struct uart4_context_t *) data;
    switch (action) {
    case UART4_APPEND_ACTION:
      pctx->buf[pctx->ptr ++] = pctx->byte;
      break;
    case UART4_RESET_ACTION:
      bzero(pctx, sizeof(struct uart4_context_t));
      pctx->countdown = (uint32_t) 0xFFFFFFFFFF;
      break;
    case UART4_APPEND_AND_SET_LEN_PLUS_1_ACTION:
      pctx->buf[pctx->ptr ++] = pctx->byte;
      pctx->countdown = pctx->byte + 1; // include crc8
      break;
    case UART4_APPEND_AND_SET_LEN0_ACTION:
      pctx->buf[pctx->ptr ++] = pctx->byte;
      pctx->len0 = pctx->byte;
      break;
    case UART4_APPEND_AND_SET_COUNTDOWN_ACTION:
      pctx->buf[pctx->ptr ++] = pctx->byte;
      pctx->countdown = ((pctx->byte << 8) | pctx->len0) & 0xFFFF;
      if (pctx->countdown + UART4_PACKET_META_SIZE > 512) {
        pctx->countdown = 512 - UART4_PACKET_META_SIZE;
      }
      break;
    case UART4_LOCK_DGZL_CALLBACK_ACTION:
      lock_callback(pctx->buf, pctx->ptr);
      bzero(pctx, sizeof(struct uart4_context_t));
      pctx->countdown = (uint32_t) 0xFFFFFFFFFF;
      break;
    case UART4_LOCK_FC_CALLBACK_ACTION:
      lock_callback(pctx->buf, pctx->ptr);
      bzero(pctx, sizeof(struct uart4_context_t));
      pctx->countdown = (uint32_t) 0xFFFFFFFFFF;
      break;
    case UART4_UART4_CALLBACK_ACTION: {
  #ifndef ENGINEER_MODE
      uart4_callback(pctx->buf, pctx->ptr);
  #endif
      bzero(pctx, sizeof(struct uart4_context_t));
      pctx->countdown = (uint32_t) 0xFFFFFFFFFF;
      break;
    }
    }
  }
#+end_src
***** 协议回调
#+begin_src c :noweb-ref uart4-callback
  static void uart4_callback(uint8_t * buf, uint32_t size) {
    uint32_t estimated = uart4_packet_estimate_decode_size(buf, size);
    uint8_t tmp[estimated];
    bzero(tmp, estimated);
    uart4_packet_t * packet = (uart4_packet_t *) tmp;
    switch (uart4_packet_decode(buf, size, estimated, packet)) {
    case CHARGER:
      charger_callback(packet);
      break;
    case RFID_READER:
      rfid_reader_callback(packet);
      break;
    default:
      break;
    }
  }
#+end_src
***** 协议封包
#+begin_src c :tangle /dev/shm/boxos/uart4-packet.h
  #ifndef __UART4_PACKET_H
  #define __UART4_PACKET_H
  #include <stdint.h>
  #include "charger_payload.h"
  #include "rfid_payload.h"
  #define UART4_PACKET_META_SIZE (4 + 4 + 1 + 1 + 2) // magic number + checksum + type and id + ver + length

  typedef enum UART4_DEV_TYPE {
    CHARGER = 0x00,
    RFID_READER = 0x10,
    ALL = 0xF0,
  } uart4_dev_type_t;

  typedef struct {
    uart4_dev_type_t devtype;
    uint8_t devid;
    uint8_t version;
    union {
      charger_payload_t charger;
      rfid_payload_t rfid_reader;
    } payload;
  } uart4_packet_t;

  uint32_t uart4_packet_calculate_encode_size(uart4_packet_t * packet);
  uint32_t uart4_packet_encode(uart4_packet_t * packet, uint8_t * buf, uint32_t size);
  uint32_t uart4_packet_estimate_decode_size(uint8_t * buf, uint8_t size);
  uart4_dev_type_t uart4_packet_decode(uint8_t * buf, uint8_t size, uint8_t estimated, uart4_packet_t * packet);

  #define _populate_uart4_packet_to_tx_1(packet, tx, line) do {           \
      uint32_t elen##line = uart4_packet_calculate_encode_size(packet);   \
      uint8_t ebuf##line[elen##line];                                     \
      uint8_t size_of_len##line = 0;                                      \
      if (elen##line < 128) {                                             \
        size_of_len##line = 1;                                            \
      } else if (elen##line < 16384) {                                    \
        size_of_len##line = 2;                                            \
      } else if (elen##line < 2097152) {                                  \
        size_of_len##line = 3;                                            \
      } else {                                                            \
        size_of_len##line = 4;                                            \
      }                                                                   \
      if (ring_available(tx) >= elen##line + size_of_len##line) {         \
        bzero(ebuf##line, elen##line);                                    \
        uint32_t len##line = uart4_packet_encode(packet, ebuf##line, elen##line); \
        elen##line = len##line;                                           \
        while (elen##line > 0) {                                          \
          ring_write(tx, elen##line & 0x7F);                              \
          elen##line = elen##line >> 7;                                   \
        }                                                                 \
        ring_write_array(tx, ebuf##line, 0, len##line);                   \
      }                                                                   \
    } while (0)

  #define _populate_uart4_packet_to_tx_0(packet, tx, line) _populate_uart4_packet_to_tx_1(packet, tx, line)

  #define populate_uart4_packet_to_tx(packet, tx) _populate_uart4_packet_to_tx_0(packet, tx, __LINE__)
  #endif
#+end_src
#+begin_src c :tangle /dev/shm/boxos/uart4-packet.c
  #include "uart4-packet.h"
  #include "hash.h"
  #include "base64.h"

  /*
    packet layout:

            +-+-+-+-+-+-+-+-+
    byte 0  |1|1|0|0|1|1|0|0|   magic number 0
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 1  |1|1|0|0|0|0|1|1|   magic number 1
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 2  |0|0|1|1|1|1|0|0|   magic number 2
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 3  |0|0|1|1|0|0|1|1|   magic number 3
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 4  |x|x|x|x|x|x|x|x|   adle32-0 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 5  |x|x|x|x|x|x|x|x|   adle32-1 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 6  |x|x|x|x|x|x|x|x|   adle32-2 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 7  |x|x|x|x|x|x|x|x|   adle32-3 of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 8  |x|x|x|x|x|x|x|x|   type (4 bit) and id (4 bit)
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte 9  |0|0|0|0|0|0|0|0|   version
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte A  |x|x|x|x|x|x|x|x|   lsb of length of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte B  |x|x|x|x|x|x|x|x|   msb of length of data
            +-+-+-+-+-+-+-+-+

            +-+-+-+-+-+-+-+-+
    byte C  |x|x|x|x|x|x|x|x|   begin of data
            +-+-+-+-+-+-+-+-+
                    .
                    .
                    .
            +-+-+-+-+-+-+-+-+
    byte n  |x|x|x|x|x|x|x|x|   end of data
            +-+-+-+-+-+-+-+-+

  ,*/



  uint32_t uart4_packet_calculate_encode_size(uart4_packet_t * packet) {
    switch (packet->devtype) {
    case CHARGER:
      return base64_encode_length(charger_payload_calculate_size(&packet->payload.charger)) + UART4_PACKET_META_SIZE;
    case RFID_READER:
      return base64_encode_length(rfid_payload_calculate_size(&packet->payload.rfid_reader)) + UART4_PACKET_META_SIZE;
    default:
      return 0;
    }
  }


  uint32_t uart4_packet_encode(uart4_packet_t * packet, uint8_t * buf, uint32_t size) {

    buf[0] = 0xCC;
    buf[1] = 0xC3;
    buf[2] = 0x3C;
    buf[3] = 0x33;
    buf[8] = (packet->devtype | packet->devid);
    buf[9] = packet->version;

    uint32_t base64len = 0;

    switch (packet->devtype) {
    case RFID_READER: {
      uint8_t zbuf[size];
      uint32_t zsize = rfid_payload_encode_zeropack(&packet->payload.rfid_reader, zbuf, size);
      base64len = base64_encode(zbuf, zsize, buf + UART4_PACKET_META_SIZE, size - UART4_PACKET_META_SIZE);
      break;
    }
    case CHARGER: {
      uint8_t zbuf[size];
      uint32_t zsize = charger_payload_encode_zeropack(&packet->payload.charger, zbuf, size);
      base64len = base64_encode(zbuf, zsize, buf + UART4_PACKET_META_SIZE, size - UART4_PACKET_META_SIZE);
      break;
    }
    default:
      break;
    }

    buf[10] = base64len & 0xFF;
    buf[11] = (base64len >> 8) & 0xFF;

    uint32_t checksum = adler32(buf + 4 + 4 /* magic + checksum */, base64len + 4 /* id + ver + len */);
    buf[4] = checksum & 0xFF;
    buf[5] = (checksum >> 8) & 0xFF;
    buf[6] = (checksum >> 16) & 0xFF;
    buf[7] = (checksum >> 24) & 0xFF;

    return base64len + UART4_PACKET_META_SIZE;
  }

  uint32_t uart4_packet_estimate_decode_size(uint8_t * buf, uint8_t size) {
    if (size <= UART4_PACKET_META_SIZE) return 0;
    if (buf[0] != 0xCC ||
        buf[1] != 0xC3 ||
        buf[2] != 0x3C ||
        buf[3] != 0x33) {
      return 0;
    }
    uint32_t len = (buf[10] + (buf[11] << 8)) & 0xFFFF;
    uint32_t checksum = adler32(buf + 4 + 4 /* magic + checksum */, len + 4 /* id + ver + len */);
    if ((buf[4] == (checksum & 0xFF)) &&
        (buf[5] == ((checksum >> 8) & 0xFF)) &&
        (buf[6] == ((checksum >> 16) & 0xFF)) &&
        (buf[7] == ((checksum >> 24) & 0xFF))) {
      switch (buf[8] & 0xF0) {
      case RFID_READER: {
        uint32_t zlen = base64_decode_length(buf + UART4_PACKET_META_SIZE, len);
        if (zlen == 0) return 0;
        uint8_t zbuf[zlen];
        base64_decode(buf + UART4_PACKET_META_SIZE, len, zbuf, zlen);
        return rfid_payload_estimate_zeropack_size(zbuf, zlen) + UART4_PACKET_META_SIZE;
      }
      case CHARGER: {
        uint32_t zlen = base64_decode_length(buf + UART4_PACKET_META_SIZE, len);
        if (zlen == 0) return 0;
        uint8_t zbuf[zlen];
        base64_decode(buf + UART4_PACKET_META_SIZE, len, zbuf, zlen);
        return charger_payload_estimate_zeropack_size(zbuf, zlen) + UART4_PACKET_META_SIZE;
      }
      default:
        return 0;
      }
    }
    return 0;
  }

  uart4_dev_type_t uart4_packet_decode(uint8_t * buf, uint8_t size, uint8_t estimated, uart4_packet_t * packet) {
    if (size < UART4_PACKET_META_SIZE) return 0;
    if (buf[0] != 0xCC ||
        buf[1] != 0xC3 ||
        buf[2] != 0x3C ||
        buf[3] != 0x33) {
      return 0;
    }
    uint32_t len = (buf[10] + (buf[11] << 8)) & 0xFFFF;
    uint32_t checksum = adler32(buf + 4 + 4 /* magic + checksum */, len + 4 /* id + ver + len */);
    if ((buf[4] == (checksum & 0xFF)) &&
        (buf[5] == ((checksum >> 8) & 0xFF)) &&
        (buf[6] == ((checksum >> 16) & 0xFF)) &&
        (buf[7] == ((checksum >> 24) & 0xFF))) {
      uint32_t zlen = base64_decode_length(buf + UART4_PACKET_META_SIZE, len);
      if (zlen == 0) return 0;
      uint8_t zbuf[zlen];
      zlen = base64_decode(buf + UART4_PACKET_META_SIZE, len, zbuf, zlen);
      packet->version = buf[9];
      packet->devtype = buf[8] & 0xF0;
      packet->devid = buf[8] & 0x0F;
      switch (buf[8] & 0xF0) {
      case RFID_READER: {
        uint8_t dbuf[estimated];
        rfid_payload_decode_zeropack(zbuf, zlen, dbuf, &packet->payload.rfid_reader);
        return RFID_READER;
      }
      case CHARGER: {
        uint8_t dbuf[estimated];
        charger_payload_decode_zeropack(zbuf, zlen, dbuf, &packet->payload.charger);
        return CHARGER;
      }
      default:
        return ALL; // for error
      }
    }
    return ALL; // for error
  }
#+end_src

** LED
#+begin_src c :tangle /dev/shm/boxos/led.h
  #ifndef _LED_H
  #define _LED_H

  #include "defination.h"

  #define led_on() do {                           \
      gpio_clear(LED_PORT, LED_IO);               \
    } while (0)

  #define led_off() do {                          \
      gpio_set(LED_PORT, LED_IO);                 \
    } while (0)

  void led_setup(void);
  #endif
#+end_src
#+begin_src c :tangle /dev/shm/boxos/led.c
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/gpio.h>
  #include "led.h"

  void led_setup() {
    rcc_periph_clock_enable (RCC_GPIOA);
    rcc_periph_clock_enable (RCC_GPIOD);

    /* Set GPIO8 (in GPIO port A) to 'output push-pull'. */
    gpio_set_mode (GPIOA, GPIO_MODE_OUTPUT_2_MHZ, GPIO_CNF_OUTPUT_PUSHPULL, GPIO8); // LED0
    /* Set GPIO2 (in GPIO port D) to 'output push-pull'. */
    //gpio_set_mode (GPIOD, GPIO_MODE_OUTPUT_2_MHZ, GPIO_CNF_OUTPUT_PUSHPULL, GPIO2); // LED1
  }
#+end_src
** 日光灯
#+begin_src c :tangle /dev/shm/boxos/light.h
  #ifndef _LIGHT_H
  #define _LIGHT_H
  #include "packet.h"
  void light_setup(void);
  void light_on(void);
  void light_off(void);
  #ifndef ENGINEER_MODE
  void light_confirm(cmd_type_t type, int16_t pin);
  #endif
  #endif
#+end_src
#+begin_src c :tangle /dev/shm/boxos/light.c
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/gpio.h>
  #include "light.h"
  #include "defination.h"
  #include "packet.h"

  void light_setup() {
    rcc_periph_clock_enable(LIGHT_RCC);
    gpio_set_mode(LIGHT_PORT, GPIO_MODE_OUTPUT_2_MHZ, GPIO_CNF_OUTPUT_PUSHPULL, LIGHT_IO);
    gpio_set(LIGHT_PORT, LIGHT_IO);
  }

  void light_on() {
    gpio_clear(LIGHT_PORT, LIGHT_IO);
  }

  void light_off() {
    gpio_set(LIGHT_PORT, LIGHT_IO);
  }

  #ifndef ENGINEER_MODE
  #include "network.h"
  #include "utility.h"
  void light_confirm(cmd_type_t type, int16_t pin) {
    parameter_t param;
    init_parameter(&param);
    param.sn = sn ++;
    param.cmd_type = type;
    param.pin = pin;
    uint8_t param_size = packet_calculate_encode_size(&param);
    uint8_t buf[param_size];
    uint8_t bufsize = packet_encode(CONFIRM, uid, &param, buf, param_size);
    network_write(buf, bufsize);
  }
  #endif
#+end_src
** 紫外灯
#+begin_src c :tangle /dev/shm/boxos/ultraviolet.h
  #ifndef _ULTRAVIOLET_H
  #define _ULTRAVIOLET_H
  #include "packet.h"
  extern int64_t ultraviolet_start_at;
  void ultraviolet_setup(void);
  void ultraviolet_on(void);
  void ultraviolet_off(void);
  #ifndef ENGINEER_MODE
  void ultraviolet_confirm(cmd_type_t cmd, int16_t pin);
  #endif
  #endif
#+end_src
#+begin_src c :tangle /dev/shm/boxos/ultraviolet.c
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/gpio.h>
  #include "ultraviolet.h"
  #include "defination.h"

  int64_t ultraviolet_start_at = 0;

  void ultraviolet_setup(void) {
    rcc_periph_clock_enable(ULTRAVIOLET_RCC);
    gpio_set_mode(ULTRAVIOLET_PORT, GPIO_MODE_OUTPUT_2_MHZ, GPIO_CNF_OUTPUT_PUSHPULL, ULTRAVIOLET_IO);
    gpio_set(ULTRAVIOLET_PORT, ULTRAVIOLET_IO);
  }

  void ultraviolet_on() {
    gpio_clear(ULTRAVIOLET_PORT, ULTRAVIOLET_IO);
    ultraviolet_start_at = timestamp;
  }

  void ultraviolet_off() {
    gpio_set(ULTRAVIOLET_PORT, ULTRAVIOLET_IO);
    ultraviolet_start_at = 0;
  }

  #ifndef ENGINEER_MODE
  #include "network.h"
  #include "utility.h"
  void ultraviolet_confirm(cmd_type_t type, int16_t pin) {
    parameter_t param;
    init_parameter(&param);
    param.sn = sn ++;
    param.cmd_type = type;
    param.pin = pin;
    uint8_t param_size = packet_calculate_encode_size(&param);
    uint8_t buf[param_size];
    uint8_t bufsize = packet_encode(CONFIRM, uid, &param, buf, param_size);
    network_write(buf, bufsize);
  }
  #endif
#+end_src
** 摄像头
#+begin_src c :tangle /dev/shm/boxos/camera.h
  #ifndef _CAMERA_H
  #define _CAMERA_H
  #include "packet.h"
  void camera_setup(void);
  void camera_on(void);
  void camera_off(void);
  void camera_confirm(cmd_type_t type, int16_t pin);
  #endif
#+end_src
#+begin_src c :tangle /dev/shm/boxos/camera.c
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/gpio.h>
  #include "camera.h"
  #include "defination.h"
  #include "network.h"
  #include "packet.h"
  #include "utility.h"

  void camera_setup() {
    rcc_periph_clock_enable(CAMERA_RCC);
    gpio_set_mode(CAMERA_PORT, GPIO_MODE_OUTPUT_2_MHZ, GPIO_CNF_OUTPUT_PUSHPULL, CAMERA_IO);
    gpio_set(CAMERA_PORT, CAMERA_IO);
  }

  void camera_on() {
    gpio_clear(CAMERA_PORT, CAMERA_IO);
  }

  void camera_off() {
    gpio_set(CAMERA_PORT, CAMERA_IO);
  }

  void camera_confirm(cmd_type_t type, int16_t pin) {
    parameter_t param;
    init_parameter(&param);
    param.sn = sn ++;
    param.cmd_type = type;
    param.pin = pin;
    uint8_t param_size = packet_calculate_encode_size(&param);
    uint8_t buf[param_size];
    uint8_t bufsize = packet_encode(CONFIRM, uid, &param, buf, param_size);
    network_write(buf, bufsize);
  }
#+end_src
** 风扇
#+begin_src c :tangle /dev/shm/boxos/fan.h
  #ifndef _FAN_H
  #define _FAN_H
  #include "packet.h"
  void fan_setup(void);
  void fan_on(void);
  void fan_off(void);
  void fan_confirm(cmd_type_t type, int16_t pin);
  #endif
#+end_src
#+begin_src c :tangle /dev/shm/boxos/fan.c
  #include <libopencm3/stm32/rcc.h>
  #include <libopencm3/stm32/gpio.h>
  #include "fan.h"
  #include "defination.h"
  #include "network.h"
  #include "packet.h"
  #include "utility.h"

  void fan_setup() {
    rcc_periph_clock_enable(FAN_RCC);
    gpio_set_mode(FAN_PORT, GPIO_MODE_OUTPUT_2_MHZ, GPIO_CNF_OUTPUT_PUSHPULL, FAN_IO);
    gpio_set(FAN_PORT, FAN_IO);
  }

  void fan_on() {
    gpio_clear(FAN_PORT, FAN_IO);
  }

  void fan_off() {
    gpio_set(FAN_PORT, FAN_IO);
  }

  void fan_confirm(cmd_type_t type, int16_t pin) {
    parameter_t param;
    init_parameter(&param);
    param.sn = sn ++;
    param.cmd_type = type;
    param.pin = pin;
    uint8_t param_size = packet_calculate_encode_size(&param);
    uint8_t buf[param_size];
    uint8_t bufsize = packet_encode(CONFIRM, uid, &param, buf, param_size);
    network_write(buf, bufsize);
  }
#+end_src
